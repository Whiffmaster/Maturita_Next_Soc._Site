"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately+table@3.11.6_react@18.2.0";
exports.ids = ["vendor-chunks/@react-stately+table@3.11.6_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@react-stately+table@3.11.6_react@18.2.0/node_modules/@react-stately/table/dist/import.mjs":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@react-stately+table@3.11.6_react@18.2.0/node_modules/@react-stately/table/dist/import.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/../node_modules/.pnpm/@react-stately+collections@3.10.5_react@18.2.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/.pnpm/next@14.1.2_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/../node_modules/.pnpm/@react-stately+grid@3.8.5_react@18.2.0/node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/../node_modules/.pnpm/@react-stately+flags@3.0.1/node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/../node_modules/.pnpm/@react-stately+utils@3.9.1_react@18.2.0/node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex items’ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the item’s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the item’s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen item’s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the item’s\n     * target main size was made smaller by this, it’s a max\n     * violation. If the item’s target main size was made\n     * larger by this, it’s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * ∑(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\n\n\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\n\n\n\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)// eslint-disable-next-line max-depth\n                if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns.find((column)=>{\n            var _column_props, _column_props1;\n            return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);\n        }).key);\n    }\n}\n\n\n\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n                // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n\n\n\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n            child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else // We enforce that the cells come before rows so can just reuse cell index\n            visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K3RhYmxlQDMuMTEuNl9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYmxlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3UDtBQUMxSDtBQUNiO0FBQ2xDO0FBQ007O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSzRzQjtBQUM1c0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K3RhYmxlQDMuMTEuNl9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYmxlL2Rpc3QvaW1wb3J0Lm1qcz8yNGEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2VjdGlvbiBhcyAkNjU1NTEwNGZmMDg1YmVmNCRyZV9leHBvcnQkU2VjdGlvbiwgdXNlQ29sbGVjdGlvbiBhcyAkMUJmalckdXNlQ29sbGVjdGlvbiwgZ2V0Rmlyc3RJdGVtIGFzICQxQmZqVyRnZXRGaXJzdEl0ZW0sIGdldExhc3RJdGVtIGFzICQxQmZqVyRnZXRMYXN0SXRlbSwgQ29sbGVjdGlvbkJ1aWxkZXIgYXMgJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCAkMUJmalckcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMUJmalckdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDFCZmpXJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxQmZqVyR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUdyaWRTdGF0ZSBhcyAkMUJmalckdXNlR3JpZFN0YXRlLCBHcmlkQ29sbGVjdGlvbiBhcyAkMUJmalckR3JpZENvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9ncmlkXCI7XG5pbXBvcnQge3RhYmxlTmVzdGVkUm93cyBhcyAkMUJmalckdGFibGVOZXN0ZWRSb3dzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZmxhZ3NcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggIT0gbnVsbCAmJiAoIWlzTmFOKHdpZHRoKSB8fCBTdHJpbmcod2lkdGgpLm1hdGNoKC9eKFxcZCspKD89JSQpLykgIT09IG51bGwpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpIHtcbiAgICBpZiAoIXdpZHRoKSByZXR1cm4gMTtcbiAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXiguKykoPz1mciQpLyk7XG4gICAgLy8gaWYgd2lkdGggaXMgdGhlIGluY29ycmVjdCBmb3JtYXQsIGp1c3QgZGVmYXVsdCBpdCB0byBhIDFmclxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB3aWR0aDogJHt3aWR0aH0gaXMgbm90IGEgc3VwcG9ydGVkIGZvcm1hdCwgd2lkdGggc2hvdWxkIGJlIGEgbnVtYmVyIChleC4gMTUwKSwgcGVyY2VudGFnZSAoZXguICc1MCUnKSBvciBmciB1bml0IChleC4gJzJmcicpYCwgXCJkZWZhdWx0aW5nIHRvICcxZnInXCIpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKFxcZCspKD89JSQpLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGVyY2VudGFnZXMgb3IgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGZvciBzdGF0aWMgY29sdW1uIHdpZHRoc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlV2lkdGggKiAocGFyc2VGbG9hdChtYXRjaFswXSkgLyAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChtYXhXaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtYXhXaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWF4V2lkdGgsIHRhYmxlV2lkdGgpIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMShtaW5XaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtaW5XaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWluV2lkdGgsIHRhYmxlV2lkdGgpIDogMDtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKGF2YWlsYWJsZVdpZHRoLCBjb2x1bW5zLCBjaGFuZ2VkQ29sdW1ucywgZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGgpIHtcbiAgICBsZXQgaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICBsZXQgZmxleEl0ZW1zID0gY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpPT57XG4gICAgICAgIHZhciBfY29sdW1uX3dpZHRoLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgbGV0IHdpZHRoID0gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpICE9IG51bGwgPyBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgOiAoX3JlZjEgPSAoX3JlZiA9IChfY29sdW1uX3dpZHRoID0gY29sdW1uLndpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3dpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3dpZHRoIDogY29sdW1uLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGdldERlZmF1bHRXaWR0aCA9PT0gbnVsbCB8fCBnZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldERlZmF1bHRXaWR0aChpbmRleCkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IFwiMWZyXCI7XG4gICAgICAgIGxldCBmcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGJhc2VTaXplID0gMDtcbiAgICAgICAgbGV0IGZsZXggPSAwO1xuICAgICAgICBsZXQgdGFyZ2V0TWFpblNpemUgPSBudWxsO1xuICAgICAgICBpZiAoJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpKSB7XG4gICAgICAgICAgICBiYXNlU2l6ZSA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxleCA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKTtcbiAgICAgICAgICAgIGlmIChmbGV4IDw9IDApIGZyb3plbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb2x1bW5fbWluV2lkdGgsIF9yZWYyO1xuICAgICAgICBsZXQgbWluID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEoKF9yZWYyID0gKF9jb2x1bW5fbWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fbWluV2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fbWluV2lkdGggOiBnZXREZWZhdWx0TWluV2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdE1pbldpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0TWluV2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiAwLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChjb2x1bW4ubWF4V2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IGh5cG90aGV0aWNhbE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihiYXNlU2l6ZSwgbWF4KSk7XG4gICAgICAgIC8vIDkuNy4xXG4gICAgICAgIC8vIFdlIGRvbid0IG1ha2UgdXNlIG9mIGZsZXggYmFzaXMsIGl0J3MgYWx3YXlzIDAsIHNvIHdlIGFyZSBhbHdheXMgaW4gJ2dyb3cnIG1vZGUuXG4gICAgICAgIC8vIDkuNy4yXG4gICAgICAgIGlmIChmcm96ZW4pIHRhcmdldE1haW5TaXplID0gaHlwb3RoZXRpY2FsTWFpblNpemU7XG4gICAgICAgIGVsc2UgaWYgKGJhc2VTaXplID4gaHlwb3RoZXRpY2FsTWFpblNpemUpIHtcbiAgICAgICAgICAgIGZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuNy4zXG4gICAgICAgIGlmICghZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm96ZW46IGZyb3plbixcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSxcbiAgICAgICAgICAgIGh5cG90aGV0aWNhbE1haW5TaXplOiBoeXBvdGhldGljYWxNYWluU2l6ZSxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBmbGV4OiBmbGV4LFxuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplLFxuICAgICAgICAgICAgdmlvbGF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gOS43LjRcbiAgICAvLyA5LjcuNC5hXG4gICAgd2hpbGUoaGFzTm9uRnJvemVuSXRlbXMpe1xuICAgICAgICAvLyA5LjcuNC5iXG4gICAgICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgYXMgZm9yIGluaXRpYWwgZnJlZSBzcGFjZSxcbiAgICAgKiBhYm92ZSAoOS43LjMpLiBJZiB0aGUgc3VtIG9mIHRoZSB1bmZyb3plbiBmbGV4IGl0ZW1z4oCZIGZsZXggZmFjdG9ycyBpc1xuICAgICAqIGxlc3MgdGhhbiBvbmUsIG11bHRpcGx5IHRoZSBpbml0aWFsIGZyZWUgc3BhY2UgYnkgdGhpcyBzdW0gKG9mIGZsZXggZmFjdG9ycykuXG4gICAgICogSWYgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWFnbml0dWRlIG9mXG4gICAgICogdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLCB1c2UgdGhpcyBhcyB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UuXG4gICAgICovIGxldCB1c2VkV2lkdGggPSAwO1xuICAgICAgICBsZXQgZmxleEZhY3RvcnMgPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmIChpdGVtLmZyb3plbikgdXNlZFdpZHRoICs9IGl0ZW0udGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1c2VkV2lkdGggKz0gaXRlbS5iYXNlU2l6ZTtcbiAgICAgICAgICAgICAgICBmbGV4RmFjdG9ycyArPSBpdGVtLmZsZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVtYWluaW5nRnJlZVNwYWNlID0gYXZhaWxhYmxlV2lkdGggLSB1c2VkV2lkdGg7XG4gICAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBpbnRlZ2VyIEZSJ3MsIGFuZCBiZWNhdXNlIG9mIGhhc05vbkZyb3plbkl0ZW1zLCB3ZSBrbm93IHRoYXQgZmxleEZhY3RvcnMgPiAwXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGZsZXhGYWN0b3JzIDwgMVxuICAgICAgICAvLyA5LjcuNC5jXG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBpcyB6ZXJvXG4gICAgICogLSBEbyBub3RoaW5nLlxuICAgICAqIEVsc2UgLy8gcmVtZW1iZXIsIHdlJ3JlIGFsd2F5cyBpbiBncm93IG1vZGVcbiAgICAgKiAtIEZpbmQgdGhlIHJhdGlvIG9mIHRoZSBpdGVt4oCZcyBmbGV4IGdyb3cgZmFjdG9yIHRvIHRoZVxuICAgICAqIHN1bSBvZiB0aGUgZmxleCBncm93IGZhY3RvcnMgb2YgYWxsIHVuZnJvemVuIGl0ZW1zIG9uXG4gICAgICogdGhlIGxpbmUuIFNldCB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB0byBpdHMgZmxleFxuICAgICAqIGJhc2Ugc2l6ZSBwbHVzIGEgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlXG4gICAgICogcHJvcG9ydGlvbmFsIHRvIHRoZSByYXRpby5cbiAgICAgKi8gaWYgKHJlbWFpbmluZ0ZyZWVTcGFjZSA+IDApIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZyb3plbikge1xuICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGl0ZW0uZmxleCAvIGZsZXhGYWN0b3JzO1xuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0TWFpblNpemUgPSBpdGVtLmJhc2VTaXplICsgcmF0aW8gKiByZW1haW5pbmdGcmVlU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5kXG4gICAgICAgIC8qKlxuICAgICAqIEZpeCBtaW4vbWF4IHZpb2xhdGlvbnMuIENsYW1wIGVhY2ggbm9uLWZyb3plbiBpdGVt4oCZc1xuICAgICAqIHRhcmdldCBtYWluIHNpemUgYnkgaXRzIHVzZWQgbWluIGFuZCBtYXggbWFpbiBzaXplc1xuICAgICAqIGFuZCBmbG9vciBpdHMgY29udGVudC1ib3ggc2l6ZSBhdCB6ZXJvLiBJZiB0aGUgaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlIHNtYWxsZXIgYnkgdGhpcywgaXTigJlzIGEgbWF4XG4gICAgICogdmlvbGF0aW9uLiBJZiB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZVxuICAgICAqIGxhcmdlciBieSB0aGlzLCBpdOKAmXMgYSBtaW4gdmlvbGF0aW9uLlxuICAgICAqLyBsZXQgdG90YWxWaW9sYXRpb24gPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gMDtcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbih0YXJnZXRNYWluU2l6ZSwgbWF4KSk7XG4gICAgICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSBpdGVtLnRhcmdldE1haW5TaXplIC0gdGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICAgICAgdG90YWxWaW9sYXRpb24gKz0gaXRlbS52aW9sYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5lXG4gICAgICAgIC8qKlxuICAgICAqIEZyZWV6ZSBvdmVyLWZsZXhlZCBpdGVtcy4gVGhlIHRvdGFsIHZpb2xhdGlvbiBpcyB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGFkanVzdG1lbnRzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKiDiiJEoY2xhbXBlZCBzaXplIC0gdW5jbGFtcGVkIHNpemUpLiBJZiB0aGUgdG90YWwgdmlvbGF0aW9uIGlzOlxuICAgICAqIFplcm9cbiAgICAgKiAtIEZyZWV6ZSBhbGwgaXRlbXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtaW4gdmlvbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIE5lZ2F0aXZlXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1heCB2aW9sYXRpb25zLlxuICAgICAqLyBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICh0b3RhbFZpb2xhdGlvbiA9PT0gMCB8fCBNYXRoLnNpZ24odG90YWxWaW9sYXRpb24pID09PSBNYXRoLnNpZ24oaXRlbS52aW9sYXRpb24pKSBpdGVtLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICghaXRlbS5mcm96ZW4pIGhhc05vbkZyb3plbkl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcyk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcykge1xuICAgIC8qXG4gIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cyB0aGF0IHN1bSB0byBhbiBpbnRlZ2VyLCB0aGlzIHJvdW5kcyB0aGUgZmxvYXRzXG4gIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzIHdpdGggdGhlIHNhbWUgc3VtLlxuICAqLyBsZXQgZnBUb3RhbCA9IDA7XG4gICAgbGV0IGludFRvdGFsID0gMDtcbiAgICBsZXQgcm91bmRlZEFycmF5ID0gW107XG4gICAgZmxleEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgZmxvYXQgPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICBsZXQgaW50ZWdlciA9IE1hdGgucm91bmQoZmxvYXQgKyBmcFRvdGFsKSAtIGludFRvdGFsO1xuICAgICAgICBmcFRvdGFsICs9IGZsb2F0O1xuICAgICAgICBpbnRUb3RhbCArPSBpbnRlZ2VyO1xuICAgICAgICByb3VuZGVkQXJyYXkucHVzaChpbnRlZ2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm91bmRlZEFycmF5O1xufVxuXG5cbmNsYXNzICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIHtcbiAgICAvKiogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgc3BsaXRzIGl0IGludG8gMiBtYXBzIG9mIGNvbHVtbnMgd2l0aCBjb250cm9sbGVkIGFuZCBjb2x1bW5zIHdpdGggdW5jb250cm9sbGVkIHdpZHRocy4gKi8gc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKT0+e1xuICAgICAgICAgICAgaWYgKGNvbC5wcm9wcy53aWR0aCAhPSBudWxsKSBhY2NbMF0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICBlbHNlIGFjY1sxXS5zZXQoY29sLmtleSwgY29sKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldyBNYXAoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFRha2VzIHVuY29udHJvbGxlZCBhbmQgY29udHJvbGxlZCB3aWR0aHMgYW5kIGpvaW5zIHRoZW0gaW50byBhIHNpbmdsZSBNYXAuICovIHJlY29tYmluZUNvbHVtbnMoY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChjb2x1bW5zLm1hcCgoY29sKT0+e1xuICAgICAgICAgICAgaWYgKHVuY29udHJvbGxlZENvbHVtbnMuaGFzKGNvbC5rZXkpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbC5rZXksXG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2wua2V5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLmdldChjb2wua2V5KS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogVXNlZCB0byBtYWtlIGFuIGluaXRpYWwgTWFwIG9mIHRoZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGJhc2VkIG9uIGRlZmF1bHQgd2lkdGhzLiAqLyBnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbSh1bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGNvbF0pPT57XG4gICAgICAgICAgICB2YXIgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoLCBfdGhpcztcbiAgICAgICAgICAgIHZhciBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCwgX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIChfcmVmID0gKF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoID0gY29sLnByb3BzLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoIDogKF90aGlzX2dldERlZmF1bHRXaWR0aCA9IChfdGhpcyA9IHRoaXMpLmdldERlZmF1bHRXaWR0aCkgPT09IG51bGwgfHwgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREZWZhdWx0V2lkdGguY2FsbChfdGhpcywgY29sKSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IFwiMWZyXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uV2lkdGgoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uV2lkdGhzX2dldCA6IDA7XG4gICAgfVxuICAgIGdldENvbHVtbk1pbldpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5NaW5XaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NYXhXaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCA9IHRoaXMuY29sdW1uTWF4V2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgcmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgY29sbGVjdGlvbiwgY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkV2lkdGhzLCBjb2wgPSBudWxsLCB3aWR0aCkge1xuICAgICAgICBsZXQgcHJldkNvbHVtbldpZHRocyA9IHRoaXMuY29sdW1uV2lkdGhzO1xuICAgICAgICAvLyByZXNpemluZyBhIGNvbHVtblxuICAgICAgICBsZXQgcmVzaXplSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IHJlc2l6aW5nQ2hhbmdlZCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgLi4uY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgICAgIC4uLnVuY29udHJvbGxlZFdpZHRoc1xuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHBlcmNlbnRLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZnJLZXlzVG9UaGVSaWdodCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IG1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gZnJlZXplIGNvbHVtbnMgdG8gdGhlIGxlZnQgdG8gdGhlaXIgcHJldmlvdXMgcGl4ZWwgdmFsdWVcbiAgICAgICAgY29sbGVjdGlvbi5jb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSk9PntcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLCBfY29sdW1uX3Byb3BzX3dpZHRoO1xuICAgICAgICAgICAgbGV0IGZyS2V5O1xuICAgICAgICAgICAgbGV0IGZyVmFsdWU7XG4gICAgICAgICAgICBtaW5XaWR0aHMuc2V0KGNvbHVtbi5rZXksIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAgICAgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhY29sdW1uLnByb3BzLndpZHRoICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5jb250cm9sbGVkIGRvbid0IGhhdmUgcHJvcHMud2lkdGggZm9yIHVzLCBzbyBpbnN0ZWFkIGdldCBmcm9tIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKGNvbHVtbi5wcm9wcy53aWR0aCkgJiYgIXVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVkV2lkdGhzIHdpbGwgYmUgdGhlIHNhbWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XG4gICAgICAgICAgICAgICAgZnJWYWx1ZSA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCkoY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICgoX2NvbHVtbl9wcm9wc193aWR0aCA9IGNvbHVtbi5wcm9wcy53aWR0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPSBfY29sdW1uX3Byb3BzX3dpZHRoLmVuZHNXaXRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLmNhbGwoX2NvbHVtbl9wcm9wc193aWR0aCwgXCIlXCIpKSkgcGVyY2VudEtleXMuc2V0KGNvbHVtbi5rZXksIGNvbHVtbi5wcm9wcy53aWR0aCk7XG4gICAgICAgICAgICAvLyBkb24ndCBmcmVlemUgY29sdW1ucyB0byB0aGUgcmlnaHQgb2YgdGhlIHJlc2l6aW5nIG9uZVxuICAgICAgICAgICAgaWYgKHJlc2l6ZUluZGV4IDwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChmcktleSkgZnJLZXlzVG9UaGVSaWdodC5zZXQoZnJLZXksIGZyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkga25vdyB0aGUgbmV3IHNpemUgb2YgdGhlIHJlc2l6aW5nIGNvbHVtblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5rZXkgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIE1hdGguZmxvb3Iod2lkdGgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmcmVlemUgY29sdW1uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIHByZXZDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByZWRpY3QgcGl4ZWxzIHNpemVzIGZvciBhbGwgY29sdW1ucyBiYXNlZCBvbiByZXNpemVcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcbiAgICAgICAgICAgICAgICAuLi5jb2wucHJvcHMsXG4gICAgICAgICAgICAgICAga2V5OiBjb2wua2V5XG4gICAgICAgICAgICB9KSksIHJlc2l6aW5nQ2hhbmdlZCwgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAvLyBzZXQgYWxsIG5ldyBjb2x1bW4gd2lkdGhzIGZvciBvblJlc2l6ZSBldmVudFxuICAgICAgICAvLyBjb2x1bW5zIGdvaW5nIGluIHdpbGwgYmUgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnMgY29taW5nIG91dFxuICAgICAgICBsZXQgbmV3V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBzZXQgYWxsIGNvbHVtbiB3aWR0aHMgYmFzZWQgb24gY2FsY3VsYXRlQ29sdW1uU2l6ZVxuICAgICAgICBjb2x1bW5XaWR0aHMuZm9yRWFjaCgod2lkdGgsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBGUidzIGJhY2sgYXMgdGhleSB3ZXJlIHRvIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIEFycmF5LmZyb20oZnJLZXlzVG9UaGVSaWdodCkuZm9yRWFjaCgoW2tleV0pPT57XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgYCR7ZnJLZXlzVG9UaGVSaWdodC5nZXQoa2V5KX1mcmApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHV0IGJhY2sgaW4gcGVyY2VudHNcbiAgICAgICAgQXJyYXkuZnJvbShwZXJjZW50S2V5cykuZm9yRWFjaCgoW2tleSwgd2lkdGhdKT0+e1xuICAgICAgICAgICAgLy8gcmVzaXppbmcgbG9ja3MgYSBjb2x1bW4gdG8gYSBweCB3aWR0aFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gY29sKSByZXR1cm47XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1dpZHRocztcbiAgICB9XG4gICAgYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgY29sbGVjdGlvbiwgd2lkdGhzKSB7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IG9yIHRhYmxlL3dpbmRvdyByZXNpemluZ1xuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgd2lkdGhzLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX21pbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKSgoX2NvbHVtbl9wcm9wc19taW5XaWR0aCA9IGNvbHVtbi5wcm9wcy5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9wcm9wc19taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9wcm9wc19taW5XaWR0aCA6IHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbHVtbiksIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzLnNldChrZXksICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCkoY29sdW1uLnByb3BzLm1heFdpZHRoLCB0YWJsZVdpZHRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRXaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA6ICgpPT5cIjFmclwiO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRNaW5XaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdE1pbldpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA6ICgpPT43NTtcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiAkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOShwcm9wcywgc3RhdGUpIHtcbiAgICBsZXQgeyBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCwgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGgsIHRhYmxlV2lkdGg6IHRhYmxlV2lkdGggPSAwIH0gPSBwcm9wcztcbiAgICBsZXQgW3Jlc2l6aW5nQ29sdW1uLCBzZXRSZXNpemluZ0NvbHVtbl0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgY29sdW1uTGF5b3V0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSkoe1xuICAgICAgICAgICAgZ2V0RGVmYXVsdFdpZHRoOiBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgICAgICBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aFxuICAgICAgICB9KSwgW1xuICAgICAgICBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgIGdldERlZmF1bHRNaW5XaWR0aFxuICAgIF0pO1xuICAgIGxldCBbY29udHJvbGxlZENvbHVtbnMsIHVuY29udHJvbGxlZENvbHVtbnNdID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyksIFtcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICAvLyB1bmNvbnRyb2xsZWQgY29sdW1uIHdpZHRoc1xuICAgIGxldCBbdW5jb250cm9sbGVkV2lkdGhzLCBzZXRVbmNvbnRyb2xsZWRXaWR0aHNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoKCk9PmNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpKTtcbiAgICAvLyBVcGRhdGUgdW5jb250cm9sbGVkIHdpZHRocyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VkLlxuICAgIGxldCBbbGFzdENvbHVtbnMsIHNldExhc3RDb2x1bW5zXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyAhPT0gbGFzdENvbHVtbnMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5sZW5ndGggIT09IGxhc3RDb2x1bW5zLmxlbmd0aCB8fCBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBsYXN0Q29sdW1uc1tpXS5rZXkpKSB7XG4gICAgICAgICAgICBsZXQgbmV3VW5jb250cm9sbGVkV2lkdGhzID0gY29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucyk7XG4gICAgICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobmV3VW5jb250cm9sbGVkV2lkdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0Q29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpO1xuICAgIH1cbiAgICAvLyBjb21iaW5lIGNvbHVtbnMgYmFjayBpbnRvIG9uZSBtYXAgdGhhdCBtYWludGFpbnMgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1uc1xuICAgIGxldCBjb2xXaWR0aHMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQucmVjb21iaW5lQ29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsIHVuY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkQ29sdW1ucywgY29udHJvbGxlZENvbHVtbnMpLCBbXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgbGV0IHN0YXJ0UmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSk9PntcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4oa2V5KTtcbiAgICB9LCBbXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXG4gICAgXSk7XG4gICAgbGV0IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSwgd2lkdGgpPT57XG4gICAgICAgIGxldCBuZXdDb250cm9sbGVkID0gbmV3IE1hcChBcnJheS5mcm9tKGNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGVudHJ5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgZW50cnkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbGV0IG5ld1NpemVzID0gY29sdW1uTGF5b3V0LnJlc2l6ZUNvbHVtbldpZHRoKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIG5ld0NvbnRyb2xsZWQsIHVuY29udHJvbGxlZFdpZHRocywga2V5LCB3aWR0aCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKEFycmF5LmZyb20odW5jb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV3U2l6ZXMuZ2V0KGtleSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbWFwLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzKG1hcCk7XG4gICAgICAgIHJldHVybiBuZXdTaXplcztcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgIHRhYmxlV2lkdGgsXG4gICAgICAgIGNvbHVtbkxheW91dCxcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzXG4gICAgXSk7XG4gICAgbGV0IGVuZFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uKG51bGwpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cbiAgICBdKTtcbiAgICAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgY29sV2lkdGhzKSwgW1xuICAgICAgICB0YWJsZVdpZHRoLFxuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLFxuICAgICAgICBjb2xXaWR0aHMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIHJldHVybiAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgcmVzaXppbmdDb2x1bW46IHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnM6IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICAgICAgc3RhcnRSZXNpemU6IHN0YXJ0UmVzaXplLFxuICAgICAgICAgICAgZW5kUmVzaXplOiBlbmRSZXNpemUsXG4gICAgICAgICAgICBnZXRDb2x1bW5XaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5XaWR0aChrZXkpLFxuICAgICAgICAgICAgZ2V0Q29sdW1uTWluV2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWluV2lkdGgoa2V5KSxcbiAgICAgICAgICAgIGdldENvbHVtbk1heFdpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1heFdpZHRoKGtleSksXG4gICAgICAgICAgICB0YWJsZVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KSwgW1xuICAgICAgICBjb2x1bW5MYXlvdXQsXG4gICAgICAgIHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1ucyxcbiAgICAgICAgc3RhcnRSZXNpemUsXG4gICAgICAgIGVuZFJlc2l6ZSxcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmxldCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG53aGlsZSgkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID09PSAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcpJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUoa2V5TWFwLCBjb2x1bW5Ob2Rlcykge1xuICAgIGlmIChjb2x1bW5Ob2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5Ob2Rlcyl7XG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBjb2x1bW4ucGFyZW50S2V5O1xuICAgICAgICBsZXQgY29sID0gW1xuICAgICAgICAgICAgY29sdW1uXG4gICAgICAgIF07XG4gICAgICAgIHdoaWxlKHBhcmVudEtleSl7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0ga2V5TWFwLmdldChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIGJyZWFrO1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgcGFyZW50LCB0aGFuIGl0IGlzIHNoYXJlZFxuICAgICAgICAgICAgLy8gd2l0aCBhIHByZXZpb3VzIGNvbHVtbi4gSWYgdGhlIGN1cnJlbnQgY29sdW1uIGlzIHRhbGxlclxuICAgICAgICAgICAgLy8gdGhhbiB0aGUgcHJldmlvdXMgY29sdW1uLCB0aGFuIHdlIG5lZWQgdG8gc2hpZnQgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gaW4gdGhlIHByZXZpb3VzIGNvbHVtbiBzbyBpdCdzIGxldmVsIHdpdGggdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbisrO1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbHVtbjogY29sdW1uLCBpbmRleDogaW5kZXggfSA9IHNlZW4uZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gY29sLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gaW5kZXg7IGkgPCBjb2wubGVuZ3RoOyBpKyspY29sdW1uLnNwbGljZShpLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3Qgc2hpZnRlZCBpbmRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gY29sLmxlbmd0aDsgaSA8IGNvbHVtbi5sZW5ndGg7IGkrKykvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbltpXSAmJiBzZWVuLmhhcyhjb2x1bW5baV0pKSBzZWVuLmdldChjb2x1bW5baV0pLmluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbHNwYW4gPSAxO1xuICAgICAgICAgICAgICAgIGNvbC5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgc2Vlbi5zZXQocGFyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudEtleSA9IHBhcmVudC5wYXJlbnRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgIGNvbHVtbi5pbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgbGV0IG1heExlbmd0aCA9IE1hdGgubWF4KC4uLmNvbHVtbnMubWFwKChjKT0+Yy5sZW5ndGgpKTtcbiAgICBsZXQgaGVhZGVyUm93cyA9IEFycmF5KG1heExlbmd0aCkuZmlsbCgwKS5tYXAoKCk9PltdKTtcbiAgICAvLyBDb252ZXJ0IGNvbHVtbnMgaW50byByb3dzLlxuICAgIGxldCBjb2xJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpe1xuICAgICAgICBsZXQgaSA9IG1heExlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY29sdW1uKXtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgc3BhY2UgdXAgdW50aWwgdGhlIGN1cnJlbnQgY29sdW1uIHdpdGggYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzW2ldO1xuICAgICAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJwbGFjZWhvbGRlci1cIiArIGl0ZW0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogY29sSW5kZXggLSByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gcGxhY2Vob2xkZXIua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIucHJldktleSA9IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0ubmV4dEtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5sZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgaXRlbS5jb2xJbmRleCA9IGNvbEluZGV4O1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbEluZGV4Kys7XG4gICAgfVxuICAgIC8vIEFkZCBwbGFjZWhvbGRlcnMgYXQgdGhlIGVuZCBvZiBlYWNoIHJvdyB0aGF0IGlzIHNob3J0ZXIgdGhhbiB0aGUgbWF4aW11bVxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCByb3cgb2YgaGVhZGVyUm93cyl7XG4gICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgIGlmIChyb3dMZW5ndGggPCBjb2x1bW5Ob2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgcm93W3Jvdy5sZW5ndGggLSAxXS5rZXksXG4gICAgICAgICAgICAgICAgY29sc3BhbjogY29sdW1uTm9kZXMubGVuZ3RoIC0gcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZLZXk6IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlclJvd3MubWFwKChjaGlsZE5vZGVzLCBpbmRleCk9PntcbiAgICAgICAgbGV0IHJvdyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVycm93XCIsXG4gICAgICAgICAgICBrZXk6IFwiaGVhZGVycm93LVwiICsgaW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0pO1xufVxuY2xhc3MgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgZXh0ZW5kcyAoMCwgJDFCZmpXJEdyaWRDb2xsZWN0aW9uKSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5ib2R5LmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICB2YXIgX2dldEZpcnN0SXRlbTtcbiAgICAgICAgcmV0dXJuIChfZ2V0Rmlyc3RJdGVtID0gKDAsICQxQmZqVyRnZXRGaXJzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHZhciBfZ2V0TGFzdEl0ZW07XG4gICAgICAgIHJldHVybiAoX2dldExhc3RJdGVtID0gKDAsICQxQmZqVyRnZXRMYXN0SXRlbSkodGhpcy5ib2R5LmNoaWxkTm9kZXMpKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldFRleHRWYWx1ZShrZXkpIHtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXJvdykgcmV0dXJuIFwiXCI7XG4gICAgICAgIC8vIElmIHRoZSByb3cgaGFzIGEgdGV4dFZhbHVlLCB1c2UgdGhhdC5cbiAgICAgICAgaWYgKHJvdy50ZXh0VmFsdWUpIHJldHVybiByb3cudGV4dFZhbHVlO1xuICAgICAgICAvLyBPdGhlcndpc2UgY29tYmluZSB0aGUgdGV4dCBvZiBlYWNoIG9mIHRoZSByb3cgaGVhZGVyIGNvbHVtbnMuXG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzO1xuICAgICAgICBpZiAocm93SGVhZGVyQ29sdW1uS2V5cykge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2Ygcm93LmNoaWxkTm9kZXMpe1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSB0aGlzLmNvbHVtbnNbY2VsbC5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlYWRlckNvbHVtbktleXMuaGFzKGNvbHVtbi5rZXkpICYmIGNlbGwudGV4dFZhbHVlKSB0ZXh0LnB1c2goY2VsbC50ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gcm93SGVhZGVyQ29sdW1uS2V5cy5zaXplKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcHJldiwgb3B0cyl7XG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgLy8gQWRkIGNlbGwgZm9yIHNlbGVjdGlvbiBjaGVja2JveGVzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykge1xuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGtleTogJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY2VsbCBmb3IgZHJhZyBidXR0b25zIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBsZXQgY29sdW1uS2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbktleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMuaXNSb3dIZWFkZXIpIHJvd0hlYWRlckNvbHVtbktleXMuYWRkKG5vZGUua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90IGdvIGludG8gY2hpbGROb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGhlYWRlclJvd3MgPSAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShjb2x1bW5LZXlNYXAsIGNvbHVtbnMpO1xuICAgICAgICBoZWFkZXJSb3dzLmZvckVhY2goKHJvdywgaSk9PnJvd3Muc3BsaWNlKGksIDAsIHJvdykpO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2x1bW5Db3VudDogY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtczogcm93cyxcbiAgICAgICAgICAgIHZpc2l0Tm9kZTogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgbm9kZS5jb2x1bW4gPSBjb2x1bW5zW25vZGUuaW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cyA9IHJvd0hlYWRlckNvbHVtbktleXM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVyUm93cyA9IGhlYWRlclJvd3M7XG4gICAgICAgIHRoaXMuX3NpemUgPSBbXG4gICAgICAgICAgICAuLi5ib2R5LmNoaWxkTm9kZXNcbiAgICAgICAgXS5sZW5ndGg7XG4gICAgICAgIC8vIERlZmF1bHQgcm93IGhlYWRlciBjb2x1bW4gdG8gdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgaWYgKHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5zaXplID09PSAwKSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuYWRkKHRoaXMuY29sdW1ucy5maW5kKChjb2x1bW4pPT57XG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wcywgX2NvbHVtbl9wcm9wczE7XG4gICAgICAgICAgICByZXR1cm4gISgoX2NvbHVtbl9wcm9wcyA9IGNvbHVtbi5wcm9wcykgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbHVtbl9wcm9wcy5pc0RyYWdCdXR0b25DZWxsKSAmJiAhKChfY29sdW1uX3Byb3BzMSA9IGNvbHVtbi5wcm9wcykgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wczEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2x1bW5fcHJvcHMxLmlzU2VsZWN0aW9uQ2VsbCk7XG4gICAgICAgIH0pLmtleSk7XG4gICAgfVxufVxuXG5cblxuY29uc3QgJDRhMGRkMDM2ZDQ5MmNlZTQkdmFyJE9QUE9TSVRFX1NPUlRfRElSRUNUSU9OID0ge1xuICAgIGFzY2VuZGluZzogXCJkZXNjZW5kaW5nXCIsXG4gICAgZGVzY2VuZGluZzogXCJhc2NlbmRpbmdcIlxufTtcbmZ1bmN0aW9uICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KHByb3BzKSB7XG4gICAgbGV0IFtpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLCBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZF0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zIH0gPSBwcm9wcztcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQxQmZqVyR1c2VDb2xsZWN0aW9uKShwcm9wcywgKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKG5vZGVzKT0+bmV3ICgwLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCkobm9kZXMsIG51bGwsIGNvbnRleHQpLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdKSwgY29udGV4dCk7XG4gICAgbGV0IHsgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIgfSA9ICgwLCAkMUJmalckdXNlR3JpZFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEJlaGF2aW9yOiBwcm9wcy5kaXNhYmxlZEJlaGF2aW9yIHx8IFwic2VsZWN0aW9uXCJcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHByb3BzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IGZhbHNlLFxuICAgICAgICBzb3J0RGVzY3JpcHRvcjogcHJvcHMuc29ydERlc2NyaXB0b3IsXG4gICAgICAgIGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCB8fCBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsXG4gICAgICAgIHNvcnQgKGNvbHVtbktleSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzX3NvcnREZXNjcmlwdG9yO1xuICAgICAgICAgICAgcHJvcHMub25Tb3J0Q2hhbmdlKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbktleSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09IHZvaWQgMCA/IGRpcmVjdGlvbiA6ICgoX3Byb3BzX3NvcnREZXNjcmlwdG9yID0gcHJvcHMuc29ydERlc2NyaXB0b3IpID09PSBudWxsIHx8IF9wcm9wc19zb3J0RGVzY3JpcHRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb3BzX3NvcnREZXNjcmlwdG9yLmNvbHVtbikgPT09IGNvbHVtbktleSA/ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTltwcm9wcy5zb3J0RGVzY3JpcHRvci5kaXJlY3Rpb25dIDogXCJhc2NlbmRpbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBjb2x1bW5zOiBjb2x1bW5zIH0gPSBwcm9wcztcbiAgICAvLyBDbGVhciBjb2x1bW5zIHNvIHRoZXkgYXJlbid0IGRvdWJsZSBhZGRlZCBpbiBzdHJpY3QgbW9kZS5cbiAgICBjb250ZXh0LmNvbHVtbnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFjb2x1bW5zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuY29sdW1ucyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgdmFsdWU6IGNvbHVtbixcbiAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjb2x1bW4pPT57XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogY29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkKiBjb2x1bW5zO1xuICAgIH1cbn07XG4vKipcbiAqIEEgVGFibGVIZWFkZXIgaXMgYSBjb250YWluZXIgZm9yIHRoZSBDb2x1bW4gZWxlbWVudHMgaW4gYSBUYWJsZS4gQ29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkXG4gKiBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBgY29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQzMTJhZTNiNTZhOTRhODZlJGV4cG9ydCRmODUwODk1YjI4N2VmMjhlID0gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcImJvZHlcIixcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuaXRlbXMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoaXRlbSk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgVGFibGVCb2R5IGlzIGEgY29udGFpbmVyIGZvciB0aGUgUm93IGVsZW1lbnRzIG9mIGEgVGFibGUuIFJvd3MgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGl0ZW1zYCBwcm9wLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgPSAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiwgY2hpbGRDb2x1bW5zOiBjaGlsZENvbHVtbnMgfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHRpdGxlIHx8IGNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdO1xuICAgIGxldCBmdWxsTm9kZXMgPSB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6ICEhY2hpbGRDb2x1bW5zIHx8IHRpdGxlICYmICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDAsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZCxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkQ29sdW1ucykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRDb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQ29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZENvbHVtbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgaXQgd29ya3MuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZW4gdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgbm9kZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBCdXQsIHdlIG5lZWQgdG8ga2VlcCB0aGUgbGlzdCBvZiBjb2x1bW5zIGluIHRoZSBuZXcgY29udGV4dCB1cCB0byBkYXRlLlxuICAgICAgICAgICAgdXBkYXRlQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZGF0ZUNvbnRleHQgPSAoY29udGV4dCk9PntcbiAgICAgICAgLy8gcmVnaXN0ZXIgbGVhZiBjb2x1bW5zIG9uIHRoZSBjb250ZXh0IHNvIHRoYXQgPFJvdz4gY2FuIGFjY2VzcyB0aGVtXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgZnVsbE5vZGVzKWlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSBjb250ZXh0LmNvbHVtbnMucHVzaChub2RlKTtcbiAgICB9O1xuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCk7XG59O1xuLyoqXG4gKiBBIENvbHVtbiByZXByZXNlbnRzIGEgZmllbGQgb2YgZWFjaCBpdGVtIHdpdGhpbiBhIFRhYmxlLiBDb2x1bW5zIG1heSBhbHNvIGNvbnRhaW4gbmVzdGVkXG4gKiBDb2x1bW4gZWxlbWVudHMgdG8gcmVwcmVzZW50IGNvbHVtbiBncm91cHMuIE5lc3RlZCBjb2x1bW5zIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXNcbiAqIGNoaWxkcmVuLCBvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgYGNoaWxkQ29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjID0gJDFjZDI0NDU1N2MyZjk3ZDUkdmFyJENvbHVtbjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0VmFsdWU6IHRleHRWYWx1ZSwgVU5TVEFCTEVfY2hpbGRJdGVtczogVU5TVEFCTEVfY2hpbGRJdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyBjZWxscyBmaXJzdFxuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd0RyYWdCdXR0b25zKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlci1kcmFnXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBjb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29udGV4dC5jb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkcmVuKGNvbHVtbi5rZXkpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbHVtbi5rZXkgLy8gdGhpcyBpcyBjb21iaW5lZCB3aXRoIHRoZSByb3cga2V5IGJ5IENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoVU5TVEFCTEVfY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgVU5TVEFCTEVfY2hpbGRJdGVtcykvLyBOb3RlOiBpbiBvcmRlciB0byByZXVzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIFRhYmxlQm9keSBmb3Igb3VyIGNoaWxkIHJvd3MsIHdlIGp1c3QgbmVlZCB0byB5aWVsZCBhIHR5cGUgYW5kIGEgdmFsdWUgaGVyZS4gQ29sbGVjdGlvbkJ1aWxkZXIgd2lsbCB0aGVuIGxvb2sgdXBcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyZW50IHJlbmRlcmVyIGFuZCB1c2UgdGhhdCB0byBidWlsZCB0aGUgZnVsbCBub2RlIG9mIHRoaXMgY2hpbGQgcm93LCB1c2luZyB0aGUgdmFsdWUgcHJvdmlkZWQgaGVyZSB0byBnZW5lcmF0ZSB0aGUgY2VsbHNcbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSb3dzID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggPCBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgb2YgYSBSb3cncyBjaGlsZCBDZWxscyBtdXN0IGJlIHBvc2l0aW9uZWQgYmVmb3JlIGFueSBjaGlsZCBSb3dzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUm93cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNlbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggIT09IGNvbnRleHQuY29sdW1ucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgQ2VsbCBjb3VudCBtdXN0IG1hdGNoIGNvbHVtbiBjb3VudC4gRm91bmQgJHtjZWxscy5sZW5ndGh9IGNlbGxzIGFuZCAke2NvbnRleHQuY29sdW1ucy5sZW5ndGh9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGNlbGxzO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZFJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgYWxsIHJvd3MgaWYgdGhlIGNvbHVtbnMgY2hhbmdlZC5cbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZXh0LmNvbHVtbnMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoIHx8IG5ld0NvbnRleHQuY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGNvbnRleHQuY29sdW1uc1tpXS5rZXkpIHx8IG5ld0NvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgIT09IGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgfHwgbmV3Q29udGV4dC5zaG93RHJhZ0J1dHRvbnMgIT09IGNvbnRleHQuc2hvd0RyYWdCdXR0b25zIHx8IG5ld0NvbnRleHQuc2VsZWN0aW9uTW9kZSAhPT0gY29udGV4dC5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgUm93IHJlcHJlc2VudHMgYSBzaW5nbGUgaXRlbSBpbiBhIFRhYmxlIGFuZCBjb250YWlucyBDZWxsIGVsZW1lbnRzIGZvciBlYWNoIGNvbHVtbi5cbiAqIENlbGxzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uXG4gKiBiYXNlZCBvbiB0aGUgY29sdW1ucyBkZWZpbmVkIGluIHRoZSBUYWJsZUhlYWRlci5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyID0gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdztcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgPyBjaGlsZHJlbiA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXSB8fCBcIlwiO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2VcbiAgICB9O1xufTtcbi8qKlxuICogQSBDZWxsIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIENvbHVtbiB3aXRoaW4gYSBUYWJsZSBSb3cuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSA9ICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsO1xuXG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuXG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNChwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucywgVU5TVEFCTEVfZXhwYW5kZWRLZXlzOiBwcm9wRXhwYW5kZWRLZXlzLCBVTlNUQUJMRV9kZWZhdWx0RXhwYW5kZWRLZXlzOiBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZTogVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBpZiAoISgwLCAkMUJmalckdGFibGVOZXN0ZWRSb3dzKSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlIGZsYWcgZm9yIHRhYmxlIG5lc3RlZCByb3dzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdXNlVHJlZUdyaWRTdGF0ZS5cIik7XG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFCZmpXJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcEV4cGFuZGVkS2V5cykgOiB1bmRlZmluZWQsIHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzID8gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cykgOiBuZXcgU2V0KCksIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UpO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zXG4gICAgXSk7XG4gICAgbGV0IGJ1aWxkZXIgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcikoKSwgW10pO1xuICAgIGxldCBub2RlcyA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0sIGNvbnRleHQpLCBbXG4gICAgICAgIGJ1aWxkZXIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjb250ZXh0XG4gICAgXSk7XG4gICAgbGV0IHRyZWVHcmlkQ29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywge1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICBleHBhbmRlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXMoJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShleHBhbmRlZEtleXMsIGtleSwgdHJlZUdyaWRDb2xsZWN0aW9uKSk7XG4gICAgfTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzLCBudWxsLCBjb250ZXh0KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzXG4gICAgXSk7XG4gICAgbGV0IHRhYmxlU3RhdGUgPSAoMCwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50YWJsZVN0YXRlLFxuICAgICAgICBrZXlNYXA6IHRyZWVHcmlkQ29sbGVjdGlvbi5rZXlNYXAsXG4gICAgICAgIHVzZXJDb2x1bW5Db3VudDogdHJlZUdyaWRDb2xsZWN0aW9uLnVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMsXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGVcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShjdXJyZW50RXhwYW5kZWRLZXlzLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgdXBkYXRlZEV4cGFuZGVkS2V5cztcbiAgICBpZiAoY3VycmVudEV4cGFuZGVkS2V5cyA9PT0gXCJhbGxcIikge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjb2xsZWN0aW9uLmZsYXR0ZW5lZFJvd3MuZmlsdGVyKChyb3cpPT5yb3cucHJvcHMuVU5TVEFCTEVfY2hpbGRJdGVtcyB8fCByb3cucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID4gY29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQpLm1hcCgocm93KT0+cm93LmtleSkpO1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMgPSBuZXcgU2V0KGN1cnJlbnRFeHBhbmRlZEtleXMpO1xuICAgICAgICBpZiAodXBkYXRlZEV4cGFuZGVkS2V5cy5oYXMoa2V5KSkgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZSB1cGRhdGVkRXhwYW5kZWRLZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEV4cGFuZGVkS2V5cztcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQoZXhwYW5kZWQpIHtcbiAgICBpZiAoIWV4cGFuZGVkKSByZXR1cm4gbmV3IFNldCgpO1xuICAgIHJldHVybiBleHBhbmRlZCA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgU2V0KGV4cGFuZGVkKTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywgb3B0cykge1xuICAgIGxldCB7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzID0gbmV3IFNldCgpIH0gPSBvcHRzO1xuICAgIGxldCBib2R5O1xuICAgIGxldCBmbGF0dGVuZWRSb3dzID0gW107XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgdXNlckNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgb3JpZ2luYWxDb2x1bW5zID0gW107XG4gICAgbGV0IGtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSBjb2x1bW5Db3VudCsrO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSBjb2x1bW5Db3VudCsrO1xuICAgIGxldCB0b3BMZXZlbFJvd3MgPSBbXTtcbiAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgIGtleU1hcC5zZXQoYm9keS5rZXksIGJvZHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB1c2VyQ29sdW1uQ291bnQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2x1bW5cIikgb3JpZ2luYWxDb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgICAgIHZpc2l0KG5vZGUpO1xuICAgIH1cbiAgICBjb2x1bW5Db3VudCArPSB1c2VyQ29sdW1uQ291bnQ7XG4gICAgLy8gVXBkYXRlIGVhY2ggZ3JpZCBub2RlIGluIHRoZSB0cmVlZ3JpZCB0YWJsZSB3aXRoIHZhbHVlcyBzcGVjaWZpYyB0byBhIHRyZWVncmlkIHN0cnVjdHVyZS4gQWxzbyBzdG9yZSBhIHNldCBvZiBmbGF0dGVuZWQgcm93IG5vZGVzIGZvciBUYWJsZUNvbGxlY3Rpb24gdG8gY29uc3VtZVxuICAgIGxldCBnbG9iYWxSb3dDb3VudCA9IDA7XG4gICAgbGV0IHZpc2l0Tm9kZSA9IChub2RlLCBpKT0+e1xuICAgICAgICAvLyBDbG9uZSByb3cgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIHNvIG1vZGlmaWNhdGlvbnMgdG8gdGhlIG5vZGUgZm9yIHRyZWVncmlkIHNwZWNpZmljIHZhbHVlcyBhcmVuJ3QgYXBwbGllZCBvbiB0aGUgbm9kZXMgcHJvdmlkZWRcbiAgICAgICAgLy8gdG8gVGFibGVDb2xsZWN0aW9uLiBJbmRleCwgbGV2ZWwsIGFuZCBwYXJlbnQga2V5cyBhcmUgYWxsIGNoYW5nZWQgdG8gcmVmbGVjdCBhIGZsYXR0ZW5lZCByb3cgc3RydWN0dXJlIHJhdGhlciB0aGFuIHRoZSB0cmVlZ3JpZCBzdHJ1Y3R1cmVcbiAgICAgICAgLy8gdmFsdWVzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB2aWEgQ29sbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxDbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjZWxsQ2xvbmUuaW5kZXggKyAxID09PSBjb2x1bW5Db3VudCkgY2VsbENsb25lLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNlbGxDbG9uZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNsb25lID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IGJvZHkua2V5LFxuICAgICAgICAgICAgICAgIGxldmVsOiAxLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnbG9iYWxSb3dDb3VudCsrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmxhdHRlbmVkUm93cy5wdXNoKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gQXNzaWduIGluZGV4T2ZUeXBlIHRvIGNlbGxzIGFuZCByb3dzIGZvciBhcmlhLXBvc2luc2V0XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiAmJiBub2RlLnR5cGUgIT09IFwiY29sdW1uXCIpIG5ld1Byb3BzW1wiaW5kZXhPZlR5cGVcIl0gPSBpO1xuICAgICAgICAvLyBVc2UgT2JqZWN0LmFzc2lnbiBpbnN0ZWFkIG9mIHNwcmVhZCB0byBwcmVzZXJ2ZSBvYmplY3QgcmVmZXJlbmNlIGZvciBrZXlNYXAuIEFsc28gZW5zdXJlcyByZXRyaWV2aW5nIG5vZGVzXG4gICAgICAgIC8vIHZpYSAuY2hpbGROb2RlcyByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgb25lIGZvdW5kIHZpYSBrZXlNYXAgbG9vayB1cFxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIG5ld1Byb3BzKTtcbiAgICAgICAga2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgbGV0IHJvd0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICghKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiICYmIGV4cGFuZGVkS2V5cyAhPT0gXCJhbGxcIiAmJiAhZXhwYW5kZWRLZXlzLmhhcyhub2RlLmtleSkpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50S2V5ID09IG51bGwpIC8vIGlmIGNoaWxkIGlzIGEgY2VsbC9leHBhbmRlZCByb3cvY29sdW1uIGFuZCB0aGUgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUubmV4dEtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdE5vZGUua2V5O1xuICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiKSB2aXNpdE5vZGUoY2hpbGQsIHJvd0luZGV4KyspO1xuICAgICAgICAgICAgZWxzZSAvLyBXZSBlbmZvcmNlIHRoYXQgdGhlIGNlbGxzIGNvbWUgYmVmb3JlIHJvd3Mgc28gY2FuIGp1c3QgcmV1c2UgY2VsbCBpbmRleFxuICAgICAgICAgICAgdmlzaXROb2RlKGNoaWxkLCBjaGlsZC5pbmRleCk7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZSkgbGFzdE5vZGUubmV4dEtleSA9IG51bGw7XG4gICAgfTtcbiAgICBsZXQgbGFzdDtcbiAgICB0b3BMZXZlbFJvd3MuZm9yRWFjaCgobm9kZSwgaSk9PntcbiAgICAgICAgdmlzaXROb2RlKG5vZGUsIGkpO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgfSBlbHNlIG5vZGUucHJldktleSA9IG51bGw7XG4gICAgICAgIGxhc3QgPSBub2RlO1xuICAgIH0pO1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleU1hcDoga2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZmxhdHRlbmVkUm93czogZmxhdHRlbmVkUm93cyxcbiAgICAgICAgdGFibGVOb2RlczogW1xuICAgICAgICAgICAgLi4ub3JpZ2luYWxDb2x1bW5zLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogZmxhdHRlbmVkUm93c1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSBhcyB1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlLCAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiBhcyB1c2VUYWJsZVN0YXRlLCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSBhcyBUYWJsZUhlYWRlciwgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgYXMgVGFibGVCb2R5LCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyBhcyBDb2x1bW4sICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIGFzIFJvdywgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgYXMgQ2VsbCwgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24gYXMgU2VjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgYXMgVGFibGVDb2xsZWN0aW9uLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZSBhcyBidWlsZEhlYWRlclJvd3MsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIGFzIFRhYmxlQ29sdW1uTGF5b3V0LCAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNCBhcyBVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@react-stately+table@3.11.6_react@18.2.0/node_modules/@react-stately/table/dist/import.mjs\n");

/***/ })

};
;